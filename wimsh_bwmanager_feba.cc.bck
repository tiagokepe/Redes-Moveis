#include <wimsh_bwmanager_feba.h>


#include <wimsh_mac.h>
#include <wimsh_topology.h>
#include <wimsh_packet.h>

#include <random.h>
#include <stat.h>

#include <iostream>
using namespace std;

WimshBwManagerFeba::WimshBwManagerFeba ( WimshMac* m) :
	WimshBwManager (m), wm_ (m)
{
}


int WimshBwManagerFeba::command (int argc, const char*const* argv) {
	return TCL_OK;
}


void WimshBwManagerFeba::recvMshDsch (WimshMshDsch* dsch){
	//cout << "gnt:" << dsch->gnt().size() << "req:" << dsch->req().size() << endl;
	recvReq(dsch);
	recvGnt(dsch);
	recvAvl(dsch);
}


void WimshBwManagerFeba::recvReq(WimshMshDsch* dsch){

	/* Lista de requisições */
	std::list< WimshMshDsch::ReqIE >req = dsch->req();

	std::list< WimshMshDsch::ReqIE >::iterator it;

	int ngh_index = mac_->neigh2ndx(dsch->src());

	for( it = req.begin(); it != req.end(); it++)
	{
		if( it->nodeId_ == mac_->nodeId()  )
		{

			// Indica ao weightManager que pode haver novo fluxo
			wm_.flow (ngh_index, wimax::IN);


			 neigh_[ngh_index].req_in_+= WimshMshDsch::pers2frames(it->persistence_) * mac_->slots2bytes(ngh_index, it->level_, false);
		//	 cout << "Recebi" << endl;
			 // Inserimos este vizinho na lista de conexões ativas,
			 // caso ele ainda não esteja lá
			 if (   neigh_[ngh_index].req_in_ > neigh_[ngh_index].gnt_in_ && !( activeList_.find(wimax::LinkId(ngh_index,wimax::IN)) )   )
				 activeList_.insert(wimax::LinkId(ngh_index,wimax::IN));
		}
	}
}

void WimshBwManagerFeba::recvGnt(WimshMshDsch* dsch){

	/* Lista de grants */
	std::list< WimshMshDsch::GntIE >gnt = dsch->gnt();

	std::list< WimshMshDsch::GntIE >::iterator it;

	for( it = gnt.begin(); it != gnt.end(); it++ )
	{
		//Indice deste vizinho
		unsigned int ngh_index = it->nodeId_;
//		 cout << "gnt:" << it->nodeId_ << ","<< mac_->nodeId() << endl;

		// Duração do frame
		unsigned int frame_range;
		unsigned int frame_start;

		realPersistence(it->frame_,it->persistence_,frame_start,frame_range);
		
		// Grant destinado a este nodo.
		if(  it->nodeId_ == mac_->nodeId() )
		{

			// É uma confirmação
			if ( it->fromRequester_ )
			{
				// Incrementamos o número de bytes de entrada confirmados.
				neigh_[ngh_index].cnf_in_ += frame_range * mac_->slots2bytes(ngh_index, it->range_, false);

				// Devemos escutar neste canal

				setSlots(channel_,frame_start,frame_range,it->start_,it->range_,it->channel_);


			}
			else // É uma concessão
			{
				// O grant é transformado em uma confirmação e guardada.
				// Alteramos o destino desta confirmação agora proque temos esta informação na mensagem.
				it->nodeId_ = dsch->src();
				it->fromRequester_ = true;

				pending_confirmations_.push_back(*it);

				neigh_[ngh_index].gnt_out_+= frame_range * mac_->slots2bytes(ngh_index, it->range_, false);

				// Slots não confirmados se tornam indisponíveis

				setSlots(unconfirmedSlots_,frame_start,frame_range,it->start_,it->range_,true);

				neigh_[ngh_index].gnt_out_ =
					( neigh_[ngh_index].gnt_out_ < neigh_[ngh_index].req_out_ ) ?
					neigh_[ngh_index].gnt_out_ : neigh_[ngh_index].req_out_; //XXX
			}
		}
		else  // Grant destinado a outro nodo
		{
			// Concessão
			if ( !(it->fromRequester_)   )
			{

				WimshMshDsch::AvlIE avl;
				avl.frame_ = it->frame_;
				avl.start_ = it->start_;
				avl.range_ = it->range_;
				avl.direction_ = WimshMshDsch::UNAVAILABLE;
				avl.persistence_ = it->persistence_;
				avl.channel_ = it->channel_;

				// push the new availability into the pending list
				availabilities_.push_back (avl);

				//
				// the granter is able to receive data from this node while
				// it is receiving data from any of its neighbors.
				// Thus, we mark the granted slots as unavailable on all channels
				//

				// number of frames over which the grant spans
				// we assume that bandwidth is never granted in the past
				unsigned int frange = WimshMshDsch::pers2frames (it->persistence_);

				// set the minislots as unavailable for the requester to transmit
				for ( unsigned int ch = 0 ; ch < mac_->nchannels() ; ch++ ) {
					setSlots (neigh_tx_unavl_[ngh_index][ch], it->frame_, frange,
							it->start_, it->range_, true);
				}

				//
				// if the requester is one of our neighbors, then we will not
				// be able to grant bandwidth to it (if requested) into the
				// set of granted slots on any channel
				//

				if ( mac_->topology()->neighbors (it->nodeId_, mac_->nodeId()) ) {
					// index of the requester
					const unsigned int ndx = mac_->neigh2ndx (it->nodeId_);

					// set the minislots as unavailable for the requester to transmit
					for ( unsigned int ch = 0 ; ch < mac_->nchannels() ; ch++ ) {
						setSlots (neigh_tx_unavl_[ndx][ch], it->frame_, frange,
								it->start_, it->range_, true);
					}
				}

				//
				// all neighbors of the granter will not be able to transmit
				// in the set of granted slots on the specified channel, which
				// is thus set as unavailable for transmission for all the
				// neighbors of the granter which are also our neighbors
				//

				std::vector<WimaxNodeId> gntNeigh;  // array of the granter's neighbors
				mac_->topology()->neighbors (dsch->src(), gntNeigh); // retrieve them
				for ( unsigned int ngh = 0 ; ngh < gntNeigh.size() ; ngh++ ) {

					// skip the requester, which has been already managed,
					// and nodes which are not our neighbors
					if ( gntNeigh[ngh] == it->nodeId_ ||
						  ! mac_->topology()->neighbors (gntNeigh[ngh], mac_->nodeId()) )
						continue;

					// otherwise, set the granted slots as unavailable
					const unsigned int ndx = mac_->neigh2ndx (gntNeigh[ngh]); // index
					setSlots (neigh_tx_unavl_[ndx][it->channel_],
							it->frame_, frange, it->start_, it->range_, true);
				}

				// Não poderemos transmitir neste canal
				setSlots (self_tx_unavl_[it->channel_],
						it->frame_, frange, it->start_, it->range_, true);
			}
			else if ( !mac_->topology()->neighbors(it->nodeId_,mac_->nodeId()) ) // Confirmação
			{
				// O destinatário desta confirmação não pode ser nosso vizinho.
				// Neste caso já teriamos cuidado de seu grant.

				// O vizinho que confirmou não poderá transmitir em nenhum canal.
				for(unsigned int ch_index = 0; ch_index < mac_->nchannels(); ch_index++)
				{
					setSlots(neigh_tx_unavl_[ngh_index][ch_index],frame_start,frame_range,it->start_,it->range_,true);
				}

				// Nós não poderemos escutar neste canal
				setSlots(self_rx_unavl_[it->channel_],frame_start,frame_range,it->start_,it->range_,true);
			}
		}
	}
}

void WimshBwManagerFeba::recvAvl(WimshMshDsch* dsch){
	/* Lista de indisponibilidades */
	std::list< WimshMshDsch::AvlIE >avl = dsch->avl();

	std::list< WimshMshDsch::AvlIE >::iterator it;

	// Índice do meu vizinho.
	int ngh_index;

	// Dados atualizados do meu frame
	unsigned int frame_start;
	unsigned int frame_range;

	// Atualizamos nossa estrutura de dados de acordo com as disponibilidades recebidas.
	for( it = avl.begin(); it != avl.end(); it++ )
	{
		if ( ( it->direction_ == WimshMshDsch::RX_ONLY) || (it->direction_ == WimshMshDsch::UNAVAILABLE ) )
		{
			ngh_index = mac_->neigh2ndx(dsch->src());
			realPersistence(it->frame_,it->persistence_,frame_start,frame_range);
			setSlots(neigh_tx_unavl_[ngh_index][it->channel_],frame_start,frame_range,it->start_,it->range_,true);
		}

	}
}

reavoid WimshBwManagerFeba::schedule (WimshMshDsch* dsch){

	//  Encaixar as disponibilidades
	 availabilities(dsch);

	// Confirmar concessões
	confirm(dsch);

	// Concessões extras para requisições que não puderam ser atendidas.
	//regrant(dsch);

	// Varre a lista de ativos para tratar requisições e concessões.
//	requestAndGrant(dsch);
	requestGrant (dsch);
}



void WimshBwManagerFeba::availabilities(WimshMshDsch* dsch) {


	// Adicione o maior número de disponibilidades possíveis
	while ( ! availabilities_.empty() ) {

		// Se não há mais espaço, paramos
		if ( dsch->remaining() < WimshMshDsch::AvlIE::size() ) break;

		WimshMshDsch::AvlIE avl = availabilities_.front();
		availabilities_.pop_front();

		// Incluimos a disponibilidade na mensagem, a não ser que esta informação não seja mais válida.
		// Corresponda a um frame que não exite mais.
		if ( mac_->frame() <=
				avl.frame_ + WimshMshDsch::pers2frames (avl.persistence_) ) {
			dsch->add (avl);
		}
	}
}

void WimshBwManagerFeba::confirm (WimshMshDsch * dsch  ){

	// Devemos confirmar o maior numero possível de concessões
	while( !pending_confirmations_.empty() ) {

		// Se não há mais espaço na mensagem, terminamos
		if ( dsch->remaining() < WimshMshDsch::GntIE::size() ) break;


		WimshMshDsch::GntIE gnt;


		// Número de bytes confirmados
		unsigned int confirmed = 0;

		gnt = pending_confirmations_.front();
		pending_confirmations_.pop_front();

		unsigned int frame_start;
		unsigned int frame_range;

		realPersistence(gnt.frame_,gnt.persistence_,frame_start, frame_range);

		unsigned int ngh_index = mac_->neigh2ndx(gnt.nodeId_);


		while ( dsch->remaining() >= WimshMshDsch::GntIE::size() ) {

			confFit(frame_start, frame_range, gnt.start_, gnt.range_, gnt);


			// Se não há mais bytes a serem confirmados, termine
			if ( gnt.range_ == 0 )
				break;

			dsch->add(gnt);

			unsigned int actual_frame_start;
			unsigned int actual_frame_range;

			realPersistence(gnt.frame_,gnt.persistence_,actual_frame_start,actual_frame_range);

			// Computamos o valor dos bytes confirmados
			confirmed += actual_frame_range * mac_->slots2bytes (ngh_index, gnt.range_, true);
			// Marcamos as estruturas de dados. Para avisar onde transmitiremos.
			setSlots(busy_,actual_frame_start,actual_frame_range,gnt.start_,gnt.range_,true);
			setSlots (grants_, actual_frame_start, actual_frame_range, gnt.start_, gnt.range_, true);
			setSlots (dst_, actual_frame_start, actual_frame_range, gnt.start_, gnt.range_, gnt.nodeId_);
			setSlots (channel_, actual_frame_start, actual_frame_range, gnt.start_, gnt.range_, gnt.channel_);
		}


		neigh_[ngh_index].cnf_out_ += confirmed;
		neigh_[ngh_index].cnf_out_ =	( neigh_[ngh_index].cnf_out_ < neigh_[ngh_index].gnt_out_ ) ?
			neigh_[ngh_index].cnf_out_ : neigh_[ngh_index].gnt_out_;



		// Se o número de requisições e menor que o de confirmações, a simulação é abortada.
		if ( neigh_[ngh_index].req_out_ < neigh_[ngh_index].cnf_out_ ) abort();

		// Os dados sobre os bytes desta confirmação são esquecidos.
		neigh_[ngh_index].gnt_out_ -= neigh_[ngh_index].cnf_out_;
		neigh_[ngh_index].req_out_ -= neigh_[ngh_index].cnf_out_;
		neigh_[ngh_index].cnf_out_ = 0;



	}

}



void WimshBwManagerFeba::confFit(unsigned int frame_start, unsigned int frame_range, unsigned int slot_start, unsigned int slot_range, WimshMshDsch::GntIE& gnt) {

	// Para cada frame
	for( unsigned int f = frame_start; f < frame_start + frame_range; f++) {
		unsigned int actual_frame = f % HORIZON;

		// Verificamos as impossibilidades de transmissão.
		const std::bitset<MAX_SLOTS> map = busy_[actual_frame] | self_tx_unavl_[gnt.channel_][actual_frame];

		// Para cada minislot
		for ( unsigned int slot = slot_start; slot < slot_start + slot_range; slot++ ) {

			if ( map[slot] == false ) {
				gnt.frame_ = f;
				gnt.start_ = slot;
				gnt.persistence_ = WimshMshDsch::FRAME1;

				// Procure o maior número de minislots
				for ( ; slot < ( slot_start + slot_range ) && map[slot] == false ; slot++ ) { }

				gnt.range_ = slot - gnt.start_;
				return;
			}
		}
	}

	// Se chegamos até aqui, retornamos um grant vazio. Não é possível conceder mais nada.
	gnt.range_ = 0;
}

void
WimshBwManagerFeba::requestGrant (WimshMshDsch* dsch)
{
	// get my handshake time, used to compute the grant horizon
	unsigned int Hslf = handshake (mac_->nodeId());

	//
	// we do not want to add request IE directly to the MSH-DSCH message
	// because doing so may unnecessarily increase the overhead (i.e.
	// the MSH-DSCH size) and the approximation error to bytes into
	// minislots multiples
	//
	// thus, we keep a counter of the bytes that we want to request
	// and an explicit variable which stores the remaining amount of
	// bytes in the MSH-DSCH message. The latter is incremented only
	// when a request to a new neighbor is added (checked via the
	// neighReq array)
	//
	// to do so, we also need to compute the maximum amount of bytes
	// that can be requested by a neighbor, which depends on the
	// burst profile currently used. If the amount of bytes requested
	// overflows this value, then we immediately add a new request
	// IE to the MSH-DSCH and update the remaining number of bytes
	// accordingly
	//

	// number of bytes that can still be allocated into the MSH-DSCH message
	unsigned int reqIeOccupancy = 0;

	// the i-th element is true if we requested bandwidth to neighbor i
	std::vector<bool> neighReq (mac_->nneighs(), false);

	// the i-th element stores the number of bytes requested to neighbor i
	std::vector<unsigned int> neighReqBytes (mac_->nneighs(), 0);

	// the i-th element stores the maximum number of bytes that can be
	// requested to neighbor i in a single IE
	std::vector<unsigned int> neighReqMax (mac_->nneighs());
	for ( unsigned int i = 0 ; i < mac_->nneighs() ; i++ ) {
		neighReqMax[i] =
			  mac_->phyMib()->slotPerFrame()
			* mac_->phyMib()->symPerSlot ()
			* WimshMshDsch::pers2frames (WimshMshDsch::FRAME128)
			* mac_->alpha (i);
	}

	// create an array of grantFitDescriptor's to be used during the
	// grant procedure to keep the current channel/frame/slot to analyze

	//
	// request bandwidth on a round robin manner
	// stop when one of the following occurs:
	// 1. the active list is empty
	// 2. there is not enough room in the MSH-DSCH to add a request/grant
	// 3. none of the links (both input and output) are eligible for service
	// 4. the round robin iterator points to a link descriptor
	//    whose deficit cannot be incremented, because doing so would
	//    overflow the maximum deficit amount, if specified
	//
	// to check 3. we use an integer number storing the index of the
	// first neighbor that was not eligible for service; if an eligible
	// link is encountered by the round-robin pointer through its walk,
	// that variable is set as not valid, to indicate that at least one link
	// is eligible
	//
	// NOTE: condition 4. is only enabled if fairGrant_ is trued
	//       otherwise, the maxDeficit_ acts as a threshold (if > 0)
	//
	unsigned int ineligible = 0;    // only meaningful with ineligibleValid true
	bool ineligibleValid = false;

	// update the deadlock detection timer
//	if ( deficitOverflow_ ) ++ddTimer_;

	while ( ! activeList_.empty() ) {                                // 1.

		// get current link information
		const unsigned int ndx         = activeList_.current().ndx_;  // index
		const unsigned int dst         = mac_->ndx2neigh (ndx);       // NodeID
		const wimax::LinkDirection dir = activeList_.current().dir_;  // direction

		// check if there are not any more eligible links
		if ( ineligibleValid && ineligible == ndx ) break;                 // 3.

		//----------------------------------------------//
		// if this is an input link, we GRANT bandwidth //
		//----------------------------------------------//

		if ( dir == wimax::IN ) {

			// stop if there is not enough room in this MSH-DSCH to add a grant
			if ( dsch->remaining() - reqIeOccupancy < WimshMshDsch::GntIE::size() )
				break;                                                       // 2.

			// get the handshake time of the neighbor currently served
			unsigned int Hdst = handshake (dst);

			// alias for the deficit counter and other variables
			unsigned int& deficit   = neigh_[ndx].lag_in_;
			unsigned int& granted   = neigh_[ndx].gnt_in_;
			unsigned int& requested = neigh_[ndx].req_in_;

			// update the deficit counter, unless we are resuming last round
			deficit += quantum (ndx, wimax::IN);


			// the deficit counter is smaller than the maxDeficit_ threshold

			// get the number of pending minislots
			unsigned int pending = requested - granted;

			// the deficit counter is smaller than the number of pending minislots
			deficit = ( deficit > pending ) ? pending : deficit;

			//
			// grant until one of the following occurs:
			// a. there is not any more spare room in the MSH-DSCH message
			// b. all the pending bytes have been made up
			// c. it is not possible to grant bandwidth over the time horizon
			//
			while ( dsch->remaining() - reqIeOccupancy
					       >= WimshMshDsch::GntIE::size() &&                // a.
					deficit > 0 ) {                                         // b.

				// get a new grant information element
				WimshMshDsch::GntIE gnt;
				// grant up to 'deficit' bytes within the time horizon
				cout << "bytes gnt:" << deficit << endl;
				gnt = grantFit(ndx,
						20,                         // max number of bytes
						mac_->frame() + Hdst,            // first eligible frame
                  mac_->frame() + 2 * Hdst + Hslf);            // current grant status

				// if the minislot range is empty, then it was not possible
				// to grant bandwidth to this node => break from this loop
				if ( gnt.range_ == 0 ) break;                              // c.

				cout << "gtn size: " << (int) gnt.range_ << endl;
				// collect the average grant size, in minislots
				Stat::put ("wimsh_gnt_size", mac_->index(), gnt.range_);

				// add the grant to the MSH-DSCH message
				dsch->add (gnt);

				// convert the grant's persistence into the number of frames
				unsigned int frange = WimshMshDsch::pers2frames (gnt.persistence_);

				// number of bytes granted
				unsigned int bgnt =
					frange * mac_->slots2bytes (ndx, gnt.range_, true);

				// update the number of bytes still needed
				// since bandwidth is granted in terms of minislots, then it
				// is possible that are granted more bytes than needed
				// in this case, we do not count the surplus allocation
				// and just reset the needed variable to zero
				deficit = ( deficit > bgnt ) ? ( deficit - bgnt ) : 0;

				// update the granted counter
				granted += bgnt;
				Stat::put ("wimsh_gnt_in", mac_->index(), bgnt);

				// set the granted slots as unavailable for reception
				setSlots (busy_, gnt.frame_, frange,
						gnt.start_, gnt.range_, true);
			}

			// if fairGrant_ in enabled and the deficit overflows
			// the maximum allowed deficit, then we exit immediately from
			// the request/grant process
	//		if ( fairGrant_ && ( deficit > maxDeficit_ ) ) {
		//		deficitOverflow_ = true;
		//		break;
		//	}

			// if needed is not zero, then this link has not been granted
			// as much bandwidth as it was entitled => mark as ineligible
			if ( ! ineligibleValid && deficit > 0 ) {
				// otherwise, we just set this queue an ineligible for service
				ineligibleValid = true;
				ineligible = ndx;
			}

			// if we granted as much as the node requested, remove this element
			// if ( granted == requested ) {  // :XXX: check this
			if ( granted >= requested ) {
				deficit = 0;
				activeList_.erase();

			// otherwise, move the active list pointer to the next element
			} else {
				activeList_.move ();
			}

		//-------------------------------------------------//
		// if this is an output link, we REQUEST bandwidth //
		//-------------------------------------------------//

		} else {   // dir == wimax::OUT

			// alias for the deficit counter and the backlog
			unsigned int& deficit   = neigh_[ndx].lag_out_;
			unsigned int& backlog   = neigh_[ndx].backlog_;
			unsigned int& confirmed = neigh_[ndx].cnf_out_;
			unsigned int& requested = neigh_[ndx].req_out_;
			unsigned int& granted   = neigh_[ndx].gnt_out_;

			/*  XXX
			// number of pending bytes (ie. requested but not confirmed)
			unsigned int pending =
				(requested > confirmed ) ? ( requested - confirmed ) : 0;
			*/

			// number of pending bytes (ie. backlogged but not requested)
			unsigned int pending =
				( backlog > requested ) ? ( backlog - requested ) : 0;

			// number of ungranted bytes (ie. requested but not granted)
			unsigned int ungranted =
				( requested > granted ) ? ( requested - granted ) : 0;

			// stop if there is not enough room in this MSH-DSCH to add a request
			if ( dsch->remaining() - reqIeOccupancy < WimshMshDsch::ReqIE::size() )
				break;                                                        // 2.

			// update the deficit counter, unless we are resuming last round
			deficit += quantum(ndx, wimax::OUT);
		//	else deficitOverflow_ = false;

			// the deficit counter is bounded by the maxDeficit_ value
	//		deficit =
		//		( ! fairRequest_ && maxDeficit_ > 0 && deficit > maxDeficit_ )
			//	? maxDeficit_ : deficit;

			// the deficit counter is bounded by the backlog
			// deficit = ( deficit > backlog ) ? backlog : deficit;
			deficit = ( deficit > pending ) ? pending : deficit;    // XXX

			// if there is too much bandwidth pending, do not request anymore
			// if ( maxBacklog_ > 0 && pending > maxBacklog_ ) {
			if (  ungranted > PENDING_MAX ) {// XXX

				// if the deadlock timer is enabled and deadlock is detected
				// when we reset the deficit of the current descriptor
				// and move it to the end of the active list
			/*	if ( ddTimeout_ > 0 && ddTimer_ >= ddTimeout_ ) {

					// :XXX: debug
					Stat::put ("wimsh_dd_timeout", mac_->index(), 1.0);

					// reset deadlock detection timer status
					ddTimer_ = 0;
					deficitOverflow_ = false;

					// reset queue status variables
					// backlog += ( requested > confirmed ) ? requested - confirmed : 0; // XXX
					granted   = 0;
					deficit   = 0;
					confirmed = 0;
					requested = 0;
				}*/

				// if fairRequest_ is enabled and the deficit overflows
				// the maximum allowed deficit, then we exit immediately from
				// the request/grant process
				if ( deficit > LAG_MAX ) {
				//	deficitOverflow_ = true;
					break;
				}

				// otherwise we mark the link as ineligible and skip it
				if ( ! ineligibleValid ) {
					ineligibleValid = true;
					ineligible = ndx;
				}

				// move the round-robin pointer to the next element
				activeList_.move();
				continue;
			}

			// if we are here, when we have to stop the deadlock detection timer
		//	if ( ddTimeout_ > 0 ) ddTimer_ = 0;

			// if we did not send a bandwidth request to this neighbor,
			// increase the occupancy of request IEs
			if ( neighReq[ndx] == false )
				reqIeOccupancy += WimshMshDsch::ReqIE::size();

			// in any case, we are now sending a bandwidth request to it
			neighReq[ndx] = true;

			// update the number of bytes that we are requesting
			neighReqBytes[ndx] += deficit;

			// the only purpose of the loop below is to add request IE
			// for bandwidth requests that overflow the maximum amount
			// of bytes that can be requested in a single request IE

			while ( neighReqBytes[ndx] > neighReqMax[ndx] ) {

				// create a request IE and
				// fill the level and persistence fields of the request IE
				// with the maximum amount that can be requested
				WimshMshDsch::ReqIE ie;
				ie.nodeId_ = mac_->ndx2neigh (ndx);
				ie.level_ = WimshMshDsch::FRAME128;

				// update the number of bytes still to be requested
				neighReqBytes[ndx] -= neighReqMax[ndx];

				// insert the IE into the MSH-DSCH message
				dsch->add (ie);
			}

			// update the requested counter
			requested += deficit;
			Stat::put ("wimsh_req_out", mac_->index(), deficit);

			// update the backlog value
			// backlog = ( backlog > deficit ) ? ( backlog - deficit ) : 0;

			// reset the deficit counter
			deficit = 0;

			// if there are no pending requests, remove the node
			// from the active list
			if ( pending == 0 ) {    // XXX
			// if ( backlog == 0 ) {
				// confirmed = requested = granted = 0; // XXX
				activeList_.erase();

			// otherwise, move the active list pointer to the next element
			} else {
				activeList_.move();
			}
		}

	}

	// add to the MSH-DSCH message the request IEs that have been
	// accounted for during the request/grant process above

	for ( unsigned int ndx = 0 ; ndx < mac_->nneighs() ; ndx++ ) {
		if ( neighReqBytes[ndx] == 0 ) continue;

		// create a request IE
		WimshMshDsch::ReqIE ie;
		ie.nodeId_ = mac_->ndx2neigh (ndx);

		// fill the level and persistence fields of the request IE
		// we are sure that the number of bytes never overflows the
		// maximum number of bytes that can be requested in a single
		// IE, since this case has been managed during the request/grant
		// process itself
		WimshMshDsch::slots2level (
				mac_->phyMib()->slotPerFrame(),
				mac_->bytes2slots (ndx, neighReqBytes[ndx], false),
				ie.level_, ie.persistence_);

		// insert the IE into the MSH-DSCH message
		dsch->add (ie);
	}
}



void WimshBwManagerFeba::requestAndGrant(WimshMshDsch* dsch){

	// Pego o tempo do meu handshake
	unsigned int HSlf = handshake(mac_->nodeId());


	unsigned int reqIeOccupancy = 0;


	std::vector<bool> neighReq (mac_->nneighs(), false);

	// the i-th element stores the number of bytes requested to neighbor i
	std::vector<unsigned int> neighReqBytes (mac_->nneighs(), 0);


	std::vector<unsigned int> neighReqMax (mac_->nneighs());
	for ( unsigned int i = 0 ; i < mac_->nneighs() ; i++ ) {
		neighReqMax[i] =
			  mac_->phyMib()->slotPerFrame()
			* mac_->phyMib()->symPerSlot ()
			* WimshMshDsch::pers2frames (WimshMshDsch::FRAME128)
			* mac_->alpha (i);
	}

	unsigned int ineligible = 0;    // only meaningful with ineligibleValid true
	bool ineligibleValid = false;



	// Enquanto a lista de conexões ainda estiver ativa, continue
	while( !activeList_.empty() )
	{
		unsigned int ngh_index = activeList_.current().ndx_;

		wimax::LinkDirection direction = activeList_.current().dir_;


		if ( ineligibleValid && ineligible == ngh_index ) break;                 // 3.


		// Se for um fluxo de entrada, eu devo conceder
		// Ver grant(i) no artigo do FEBA
		if( direction == wimax::IN ){
			unsigned int HDst = handshake(mac_->ndx2neigh(ngh_index));

			// Se a mensagem estiver cheia, eu não incluo mais grants
			if ( dsch->remaining() - reqIeOccupancy < WimshMshDsch::GntIE::size()  )
				break;


			// lag_i_in <- min{lag_i_in + quantum, req_i_in - gnt_i_in}
			unsigned int pending_bytes = neigh_[ngh_index].req_in_ - neigh_[ngh_index].gnt_in_;
			neigh_[ngh_index].lag_in_+=quantum(ngh_index,wimax::IN);
			neigh_[ngh_index].lag_in_= ( neigh_[ngh_index].lag_in_ > pending_bytes) ? pending_bytes : neigh_[ngh_index].lag_in_;

			cout << "DDIN:" << neigh_[ngh_index].lag_in_ << endl;

			// Adiciono grants de acordo com o DRR
			while ( ( dsch->remaining() - reqIeOccupancy >= WimshMshDsch::GntIE::size() ) && (neigh_[ngh_index].lag_in_ > 0 ) ){
				cout << "DDIN2" << endl;

				WimshMshDsch::GntIE gnt;

				// Procuramos um espaço para nosso grant
				// granted = fit(i, lag_i_in, h_neigh, h_neigh + h_self
				gnt = grantFit(ngh_index, neigh_[ngh_index].lag_in_ ,mac_->frame() + HDst , mac_->frame() + 2*HDst + HSlf); //initial horizon, limit horizon );

				//
				// Se não achamos nenhum espaço no horizonte de alocação,
				// então não há mais o que alocar.
				 //
				if ( gnt.range_ == 0 ) break;
			//	cout << "gnt size:" << gnt.range_ << endl;
				dsch->add(gnt);

				// Precisamos descobrir o número de bytes concedidos
				unsigned int frame_range = WimshMshDsch::pers2frames(gnt.persistence_);
				unsigned int bytes_granted = frame_range * mac_->slots2bytes(ngh_index,gnt.range_,true);

				//gnt_i_in = gnt_i_in + granted
				neigh_[ngh_index].gnt_in_+=bytes_granted;

				// lag_i_in = lag_i_in - granted
				neigh_[ngh_index].lag_in_ = (  neigh_[ngh_index].lag_in_ > bytes_granted ) ?  neigh_[ngh_index].lag_in_ - bytes_granted : 0;

				// Não podemos mais receber nenhuma transmissão neste canal
				setSlots(busy_, gnt.frame_, frame_range, gnt.start_, gnt.range_, true);
			}

			// if ( lag_i_in > lag_max ) terminate
			if ( neigh_[ngh_index].lag_in_ > LAG_MAX )
				break;

			if ( ! ineligibleValid && neigh_[ngh_index].lag_in_ > 0 ) {
				// otherwise, we just set this queue an ineligible for service
				ineligibleValid = true;
				ineligible = ngh_index;
			}

			//
			// Precisamos mover o ponteiro de nossa lista ativa,
			// há dois casos:
			// - As requisições já foram satisfeitas
			// - Round Robin.
			//

			if ( neigh_[ngh_index].gnt_in_ >= neigh_[ngh_index].req_in_ )
			{
				neigh_[ngh_index].lag_in_ = 0;
				activeList_.erase();
			}
			else
			{
				activeList_.move();
			}
		} // Se for um fluxo de saída, eu devo requisitar. wimax::OUT
		else{
		//	cout << "DRROUT" << endl;
/*
			// Número de bytes a serem requisitados
			unsigned int pending_bytes = ( neigh_[ngh_index].backlog_ > neigh_[ngh_index].req_out_ )? neigh_[ngh_index].backlog_ - neigh_[ngh_index].req_out_:0;

			// Se não há espaço suficiente na mensagem, paramos
			if ( dsch->remaining() < WimshMshDsch::ReqIE::size() )
				break;

			// lag_i_out = min{ lag_i_out + quantum, blog_i_out}
			neigh_[ngh_index].lag_out_ += quantum(ngh_index,wimax::OUT);
			neigh_[ngh_index].lag_out_ = ( neigh_[ngh_index].lag_out_ > pending_bytes )?pending_bytes: neigh_[ngh_index].lag_out_;

			unsigned int ungranted = ( neigh_[ngh_index].req_out_ > neigh_[ngh_index].gnt_out_ )? neigh_[ngh_index].req_out_ - neigh_[ngh_index].gnt_out_ : 0;

			// if ( req_i_out - cnf_i_out > pending_max )
			// Aqui usamos gnt_i_out ao invés de cnf_i_out. As confirmações sempre são feitas posteriormente.
			if (  ungranted > PENDING_MAX  ) {


				// If (lag_i_out > lag_max) terminate
				if ( neigh_[ngh_index].lag_out_ > LAG_MAX )
					break;


				// Movemos o ponteiro do Round Robin para o próximo elemento
				activeList_.move();
				continue;
			}

			if ( pending_bytes > 0) {
				WimshMshDsch::ReqIE reqie;
				reqie.nodeId_ = mac_->ndx2neigh(ngh_index);

				// Adicionamos a requisição
				unsigned int nslots = mac_->bytes2slots(ngh_index,neigh_[ngh_index].lag_out_,false);
				WimshMshDsch::slots2level(mac_->phyMib()->slotPerFrame(), nslots ,reqie.level_,reqie.persistence_ );

				dsch->add(reqie);

				// Atualizamos o número de bytes requisitados
				// req_i_out = req_i_out + needed
				neigh_[ngh_index].req_out_ += neigh_[ngh_index].lag_out_;

				// lag_i_out = 0
				neigh_[ngh_index].lag_out_ = 0;

				// O neigh_i.backlog só será atualizado após a mensagem ter sido enviada de fato.
			}


			if ( pending_bytes <= 0  )
			{
				activeList_.erase();
			}
			else
			{
				activeList_.move();
			}
			*/
			unsigned int& deficit   = neigh_[ngh_index].lag_out_;
			unsigned int& backlog   = neigh_[ngh_index].backlog_;
		//	unsigned int& confirmed = neigh_[ngh_index].cnf_out_;
			unsigned int& requested = neigh_[ngh_index].req_out_;
			unsigned int& granted   = neigh_[ngh_index].gnt_out_;



			// number of pending bytes (ie. backlogged but not requested)
			unsigned int pending =
				( backlog > requested ) ? ( backlog - requested ) : 0;

			// number of ungranted bytes (ie. requested but not granted)
			unsigned int ungranted =
				( requested > granted ) ? ( requested - granted ) : 0;

			// stop if there is not enough room in this MSH-DSCH to add a request
			if ( dsch->remaining() - reqIeOccupancy < WimshMshDsch::ReqIE::size() )
				break;                                                        // 2.

			// update the deficit counter, unless we are resuming last round
			deficit += quantum (ngh_index, wimax::OUT);


			// the deficit counter is bounded by the maxDeficit_ value

			// the deficit counter is bounded by the backlog
			// deficit = ( deficit > backlog ) ? backlog : deficit;
			deficit = ( deficit > pending ) ? pending : deficit;    // XXX

			// if there is too much bandwidth pending, do not request anymore
			// if ( maxBacklog_ > 0 && pending > maxBacklog_ ) {
			if (  ungranted > PENDING_MAX ) {// XXX

				// if the deadlock timer is enabled and deadlock is detected
				// when we reset the deficit of the current descriptor
				// and move it to the end of the active list

				// if fairRequest_ is enabled and the deficit overflows
				// the maximum allowed deficit, then we exit immediately from
				// the request/grant process
				if ( deficit > LAG_MAX )
					break;


				// otherwise we mark the link as ineligible and skip it
				if ( ! ineligibleValid ) {
					ineligibleValid = true;
					ineligible = ngh_index;
				}

				// move the round-robin pointer to the next element
				activeList_.move();
				continue;
			}


			// if we did not send a bandwidth request to this neighbor,
			// increase the occupancy of request IEs
			if ( neighReq[ngh_index] == false )
				reqIeOccupancy += WimshMshDsch::ReqIE::size();

			// in any case, we are now sending a bandwidth request to it
			neighReq[ngh_index] = true;

			// update the number of bytes that we are requesting
			neighReqBytes[ngh_index] += deficit;

			// the only purpose of the loop below is to add request IE
			// for bandwidth requests that overflow the maximum amount
			// of bytes that can be requested in a single request IE

			while ( neighReqBytes[ngh_index] > neighReqMax[ngh_index] ) {

				// create a request IE and
				// fill the level and persistence fields of the request IE
				// with the maximum amount that can be requested
				WimshMshDsch::ReqIE ie;
				ie.nodeId_ = mac_->ndx2neigh (ngh_index);
				ie.level_ = WimshMshDsch::FRAME128;

				// update the number of bytes still to be requested
				neighReqBytes[ngh_index] -= neighReqMax[ngh_index];

				// insert the IE into the MSH-DSCH message
				dsch->add (ie);
			}

			// update the requested counter
			requested += deficit;
			Stat::put ("wimsh_req_out", mac_->index(), deficit);

			// update the backlog value
			// backlog = ( backlog > deficit ) ? ( backlog - deficit ) : 0;

			// reset the deficit counter
			deficit = 0;

			// if there are no pending requests, remove the node
			// from the active list
			if ( pending == 0 ) {    // XXX
			// if ( backlog == 0 ) {
				// confirmed = requested = granted = 0; // XXX
				activeList_.erase();

			// otherwise, move the active list pointer to the next element
			} else {
				activeList_.move();
			}


		}

	}

	for ( unsigned int ngh_index = 0 ; ngh_index < mac_->nneighs() ; ngh_index++ ) {
		if ( neighReqBytes[ngh_index] == 0 ) continue;

		// create a request IE
		WimshMshDsch::ReqIE ie;
		ie.nodeId_ = mac_->ndx2neigh (ngh_index);

		// fill the level and persistence fields of the request IE
		// we are sure that the number of bytes never overflows the
		// maximum number of bytes that can be requested in a single
		// IE, since this case has been managed during the request/grant
		// process itself
		WimshMshDsch::slots2level (
				mac_->phyMib()->slotPerFrame(),
				mac_->bytes2slots (ngh_index, neighReqBytes[ngh_index], false),
				ie.level_, ie.persistence_);

		// insert the IE into the MSH-DSCH message
		dsch->add (ie);
	}
}

/*
 * Encaixa um grant em um espaço livre no horizonte de tempo definido.
 */
WimshMshDsch::GntIE  WimshBwManagerFeba::fit( unsigned int ngh_index, unsigned int bytes, unsigned int min_frame, unsigned int max_frame) {


	// Grant a ser retornado por esta função
	WimshMshDsch::GntIE gnt;

	gnt.nodeId_ = mac_->ndx2neigh(ngh_index);


	// Número de slots por frame
	unsigned int slots_frame = mac_->phyMib()->slotPerFrame();


	// Para cada frame no horizonte
	for(unsigned int f = min_frame; f<=max_frame ; f++)
	{
		// Colocamos o frame em valores reais
		unsigned int actual_frame = f % HORIZON;

		// Canal a ser usado
		unsigned int channel;
		channel = fitGnt.uniform((int) mac_->nchannels());

		// Para cada canal
		for(unsigned int c = 0; c < mac_->nchannels(); c++) {

				// Marcamos os slots que não podemos conceder.
				std::bitset<MAX_SLOTS> map = unconfirmedSlots_[actual_frame] |
					busy_[actual_frame] | self_rx_unavl_[channel][actual_frame] |
					neigh_tx_unavl_[ngh_index][channel][actual_frame];

				for( unsigned int slot; slot < slots_frame ; slot++)
				{
					if ( map[slot] == false ) {
						gnt.frame_ = f;
						gnt.start_ = slot;
						gnt.persistence_ = WimshMshDsch::FRAME1;
						gnt.fromRequester_ = false;
						gnt.channel_ = channel;

						// search for the largest minislot range
						unsigned int maxSlots = mac_->bytes2slots (ngh_index, bytes, true);
						for ( ; slot < slots_frame && map[slot] == false &&
						( slot - gnt.start_ ) < maxSlots ; slot++ ) { }

						gnt.range_ = slot - gnt.start_;

						if ( gnt.range_ != maxSlots  )
							continue;
						cout << "retorno" << endl;
						return gnt;
					}

				}
				// Pulamos para o próximo canal.
				channel = ( channel + 1 )%mac_->nchannels();
		}
	}

	// Se chegamos até aqui não foi possível alocar banda.
	gnt.range_ = 0;
	return gnt;
}

WimshMshDsch::GntIE
WimshBwManagerFeba::grantFit (
		unsigned int ndx, unsigned int bytes,
		unsigned int minFrame, unsigned int maxFrame)
{
	// new grant to be returned (and then added to the MSH-DSCH)
	WimshMshDsch::GntIE gnt;
	gnt.nodeId_ = mac_->ndx2neigh (ndx);

	// number of minislots per frame
	unsigned int N = mac_->phyMib()->slotPerFrame();

	// number of channels
	unsigned int C = mac_->nchannels();



	// for each frame in the time window
	for ( unsigned int f = minFrame ; f <= maxFrame ; f++ ) {
		// set the actual frame number within the frame horizon
		unsigned int F = f % HORIZON;

		// pick up a random channel, if required
		unsigned int ch = 0;
		ch = fitGnt.uniform ((int)C);

		// for each channel
		for ( unsigned int c = 0 ; c < C ; c++ ) {

			// get a bitset which represents the grant unavailabilities
			std::bitset<MAX_SLOTS> map =
			  unconfirmedSlots_[F] | busy_[F] |
			  self_rx_unavl_[ch][F] | neigh_tx_unavl_[ndx][ch][F];

			// for each minislot in the current frame
			for ( unsigned int s = 0 ; s < N ; s++ ) {

				// as soon as a free minislot is found, start the grant allocation
				if ( map[s] == false ) {
					gnt.frame_ = f;
					gnt.start_ = s;
					gnt.persistence_ = WimshMshDsch::FRAME1;
					gnt.fromRequester_ = false;
					gnt.channel_ = ch;

					// search for the largest minislot range
					unsigned int maxSlots = mac_->bytes2slots (ndx, bytes, true);
					for ( ; s < N && map[s] == false &&
						( s - gnt.start_ ) < maxSlots ; s++ ) { }

					gnt.range_ = s - gnt.start_;

					// check the minimum number of OFDM symbols per grant
					// unless the number of slots requested is smaller than that
					unsigned int symbols =
						  gnt.range_ * mac_->phyMib()->symPerSlot()
						- mac_->phyMib()->symShortPreamble();

					if ( gnt.range_ != maxSlots && symbols < 1 )
						continue;

					return gnt;
				}
			} // for each minislot

			// set the actual channel number
			ch = ( ch + 1 ) % C;

		} // for each channel
	} // for each frame

	// if we reach this point, then it is not possible to grant bandwidth
	gnt.range_ = 0;  // in this case, the other fields are not meaningful
	return gnt;
}

void WimshBwManagerFeba::initialize (){

	int nneighbors = mac_->nneighs();
	neigh_.resize(nneighbors);

	neigh_tx_unavl_.resize(nneighbors);

	busy_.resize(HORIZON);
	unconfirmedSlots_.resize(HORIZON);

	for(int fr_index = 0; fr_index < HORIZON; fr_index++)
	{
		busy_[fr_index].reset();
		unconfirmedSlots_[fr_index].reset();
	}


	// Para cada vizinho
	for(int ngh_index=0; ngh_index < nneighbors; ngh_index++)
	{
		neigh_tx_unavl_[ngh_index].resize(mac_->nchannels());
		//Para cada canal
		for(unsigned int ch_index=0; ch_index < mac_->nchannels(); ch_index++)
		{
			neigh_tx_unavl_[ngh_index][ch_index].resize(HORIZON);

			// Para cada frame
			for( int fr_index = 0; fr_index < HORIZON; fr_index++)
			{
				neigh_tx_unavl_[ngh_index][ch_index][fr_index].reset();
			}
		}
	}

	self_rx_unavl_.resize(mac_->nchannels());
	self_tx_unavl_.resize(mac_->nchannels());
	//Para cada canal
	for(unsigned int ch_index=0; ch_index < mac_->nchannels(); ch_index++)
	{
		self_rx_unavl_[ch_index].resize(HORIZON);
		self_tx_unavl_[ch_index].resize(HORIZON);
		// Para cada frame
		for(int fr_index = 0; fr_index < HORIZON; fr_index++)
		{
			self_rx_unavl_[ch_index][fr_index].reset();
			self_tx_unavl_[ch_index][fr_index].reset();
		}
	}

	wm_.initialize();


}
/*
 * Desejamos enviar uma quantidade de bytes a um determinado nodo
 */
void WimshBwManagerFeba::backlog (WimaxNodeId src, WimaxNodeId dst, unsigned char prio, WimaxNodeId nexthop, unsigned int bytes){

	// Índice do meu vizinho
	const unsigned int ndx = mac_->neigh2ndx(nexthop);

	// Adicionamos este fluxo ao pesador de fluxos
	wm_.flow(src,dst,prio,ndx,wimax::OUT);


	neigh_[ndx].backlog_+=bytes;

	// Este fluxo precisa ser adicionado se não existir, para que o alocador em Deficit Round Robin possa ser usado.
	if (  !activeList_.find(wimax::LinkId(ndx, wimax::OUT))  )
		activeList_.insert(wimax::LinkId(ndx,wimax::OUT));
}
	
void WimshBwManagerFeba::backlog (WimaxNodeId nexthop, unsigned int bytes){

	// Índice do meu vizinho
	const unsigned int ndx = mac_->neigh2ndx(nexthop);

	wm_.flow(ndx, wimax::OUT);

	neigh_[ndx].backlog_+=bytes;

	if (  !activeList_.find(wimax::LinkId(ndx, wimax::OUT))  )
		activeList_.insert(wimax::LinkId(ndx,wimax::OUT));
}

void WimshBwManagerFeba::sent (WimaxNodeId nexthop, unsigned int bytes){

	const unsigned int ngh_index = mac_->ndx2neigh(nexthop);

	// Atualizamos o backlog aqui ( ver requestAndgrant) .
	neigh_[ngh_index].backlog_ -= bytes;
}

void WimshBwManagerFeba::realPersistence(unsigned int frame_start, WimshMshDsch::Persistence frame_range, unsigned int &actual_frame_start, unsigned int &actual_frame_range){
	actual_frame_range = WimshMshDsch::pers2frames(frame_range);

	actual_frame_range -= ( frame_start > mac_->frame() )? 0 : mac_->frame() - frame_start  ;

	if ( actual_frame_range < 0  ) actual_frame_range = 0;

	actual_frame_start = ( frame_start >= mac_->frame() )? frame_start : mac_->frame();
}

WimshMshDsch::AvlIE WimshBwManagerFeba::createAvl(WimshMshDsch::GntIE gnt, WimshMshDsch::Direction dir) {
	WimshMshDsch::AvlIE avl;

	avl.channel_ = gnt.channel_;
	avl.frame_ = gnt.frame_;
	avl.persistence_ = gnt.persistence_;
	avl.start_ = gnt.start_;
	avl.range_ = gnt.range_;
	avl.direction_ = dir;

	return avl;
}

